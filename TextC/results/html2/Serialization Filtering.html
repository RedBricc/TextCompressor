<!DOCTYPE html
  SYSTEM "about:legacy-compat">
<html xml:lang="en-us" lang="en-us">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
      <meta name="DC.Type" content="topic">
      <meta name="DC.Title" content="Serialization Filtering">
      <meta name="abstract" content="You can use the Java serialization filtering mechanism to help prevent deserialization vulnerabilities. You can define pattern-based filters or you can create custom filters.">
      <meta name="description" content="You can use the Java serialization filtering mechanism to help prevent deserialization vulnerabilities. You can define pattern-based filters or you can create custom filters.">
      <meta name="DC.Publisher" content="March2022">
      <meta name="DC.Format" content="XHTML">
      <meta name="DC.Identifier" content="GUID-3ECB288D-E5BD-4412-892F-E9BB11D4C98A">
      <meta name="DC.Language" content="en-US">
      <meta name="viewport" content="width=device-width, initial-scale=1">
      <meta http-equiv="X-UA-Compatible" content="IE=edge">
      <meta name="abstract" content="You can use the Java serialization filtering mechanism to help prevent deserialization vulnerabilities. You can define pattern-based filters or you can create custom filters.">
      <meta name="description" content="You can use the Java serialization filtering mechanism to help prevent deserialization vulnerabilities. You can define pattern-based filters or you can create custom filters.">
      <title>Serialization Filtering</title>
      <meta property="og:site_name" content="Oracle Help Center">
      <meta property="og:title" content="Core Libraries">
      <meta property="og:description" content="You can use the Java serialization filtering mechanism to help prevent deserialization vulnerabilities. You can define pattern-based filters or you can create custom filters.">
      <link rel="stylesheet" href="/sp_common/book-template/ohc-book-template/css/book.css">
      <link rel="shortcut icon" href="/sp_common/book-template/ohc-common/img/favicon.ico">
      <meta name="application-name" content="Core Libraries">
      <meta name="generator" content="DITA Open Toolkit version 1.8.5 (Mode = doc)">
      <meta name="plugin" content="SP_docbuilder HTML plugin release 18.2.2">
      <link rel="alternate" href="java-core-libraries-developer-guide.pdf" title="PDF File" type="application/pdf">
      <meta name="robots" content="all">
      <link rel="schema.dcterms" href="http://purl.org/dc/terms/">
      <meta name="dcterms.created" content="2022-03-17T05:24:43-07:00">
      
      <meta name="dcterms.dateCopyrighted" content="2017, 2022">
      <meta name="dcterms.category" content="java">
      <meta name="dcterms.identifier" content="F47639-01">
      
      <meta name="dcterms.product" content="en/java/javase/18">
      <meta name="dcterms.release" content="18">
      <link rel="prev" href="java-core-libraries1.html" title="Previous" type="text/html">
      <link rel="next" href="enhanced-deprecation1.html" title="Next" type="text/html">
      <script>
        document.write('<style type="text/css">');
        document.write('body > .noscript, body > .noscript ~ * { visibility: hidden; }');
        document.write('</style>');
     </script>
      <script data-main="/sp_common/book-template/ohc-book-template/js/book-config" src="/sp_common/book-template/requirejs/require.js"></script>
      <script>
            if (window.require === undefined) {
                document.write('<script data-main="sp_common/book-template/ohc-book-template/js/book-config" src="sp_common/book-template/requirejs/require.js"><\/script>');
                document.write('<link href="sp_common/book-template/ohc-book-template/css/book.css" rel="stylesheet"/>');
            }
        </script>
      <script type="application/json" id="ssot-metadata">{"primary":{"category":{"short_name":"java","element_name":"Java","display_in_url":true},"suite":{"short_name":"not-applicable","element_name":"Not Applicable","display_in_url":false},"product_group":{"short_name":"not-applicable","element_name":"Not Applicable","display_in_url":false},"product":{"short_name":"javase","element_name":"Java SE","display_in_url":true},"release":{"short_name":"18","element_name":"18","display_in_url":true}}}</script>
      
    <meta name="dcterms.title" content="Java Core Libraries Developer Guide">
    <meta name="dcterms.isVersionOf" content="CORE">
  <script type="application/ld+json"> {"@context":"https://schema.org","@type":"WebPage","name":"Serialization Filtering","description":"You can use the Java serialization filtering mechanism to help prevent deserialization vulnerabilities. You can define pattern-based filters or you can create custom filters.","datePublished":"2018-09-25 13:22:25 GMT","dateModified":"2022-03-17 05:28:57 PDT"} </script>
    <script>window.ohcglobal || document.write('<script src="/en/dcommon/js/global.js">\x3C/script>')</script></head>
   <body>
      <div class="noscript alert alert-danger text-center" role="alert">
         <a href="java-core-libraries1.html" class="pull-left"><span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>Previous</a>
         <a href="enhanced-deprecation1.html" class="pull-right">Next<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span></a>
         <span class="fa fa-exclamation-triangle" aria-hidden="true"></span> JavaScript must be enabled to correctly display this content
        
      </div>
      <article>
         <header>
            <ol class="breadcrumb" vocab="http://schema.org/" typeof="BreadcrumbList">
               <li property="itemListElement" typeof="ListItem"><a href="index.html" property="item" typeof="WebPage"><span property="name">Core Libraries</span></a></li>
               <li class="active" property="itemListElement" typeof="ListItem">Serialization Filtering</li>
            </ol>
            <a id="GUID-3ECB288D-E5BD-4412-892F-E9BB11D4C98A" name="GUID-3ECB288D-E5BD-4412-892F-E9BB11D4C98A"></a>
            
            <h2 id="JSCOR-GUID-3ECB288D-E5BD-4412-892F-E9BB11D4C98A" class="sect2"><span class="enumeration_chapter">2 </span>Serialization Filtering
            </h2>
         </header>
         <div class="ind">
            <div>
               <p>You can use the Java serialization filtering mechanism to help prevent deserialization vulnerabilities. You can define pattern-based filters or you can create custom filters.</p>
               <div class="section">
                  <p class="subhead1" id="GUID-3ECB288D-E5BD-4412-892F-E9BB11D4C98A__GUID-A1F99FA7-F03B-4A05-AC6A-BBC71C48F7D2">Topics:</p>
                  <ul style="list-style-type: disc;">
                     <li><a href="serialization-filtering1.html#GUID-55BABE96-3048-4A9F-A7E6-781790FF3480" title="An application that accepts untrusted data and deserializes it is vulnerable to attacks. You can create filters to screen incoming streams of serialized objects before they are deserialized.">Addressing Deserialization Vulnerabilities</a></li>
                     <li><a href="serialization-filtering1.html#GUID-8296D8E8-2B93-4B9A-856E-0A65AF9B8C66" title="The Java serialization filtering mechanism screens incoming streams of serialized objects to help improve security and robustness. Filters can validate incoming instances of classes before they are deserialized.">Java Serialization Filters</a></li>
                     <li><a href="serialization-filtering1.html#GUID-5456D226-396D-4916-8DB2-A13BB1BF49C1">Filter Factories</a></li>
                     <li><a href="serialization-filtering1.html#GUID-952E2328-AB66-4412-8B6B-3BCCB3195C25" title="Allow-lists and reject-lists can be implemented using pattern-based filters or custom filters. These lists allow you to take proactive and defensive approaches to protect your applications.">Allow-Lists and Reject-Lists</a></li>
                     <li><a href="serialization-filtering1.html#GUID-91735293-E38E-4A81-85DC-719AFEB36026" title="Pattern-based filters are filters that you define without changing your application code. You add JVM-wide filters in properties files or application-specific filters on the java command line.">Creating Pattern-Based Filters</a></li>
                     <li><a href="serialization-filtering1.html#GUID-0A1D23AB-2F18-4979-9288-9CFEC04F207E" title="Custom filters are filters you specify in your application’s code. They are set on an individual stream or on all streams in a process. You can implement a custom filter as a pattern, a method, a lambda expression, or a class.">Creating Custom Filters</a></li>
                     <li><a href="serialization-filtering1.html#GUID-884D0115-2F99-4094-8499-4F25E37410F8" title="A filter factory is a BinaryOperator, which is a function of two operands that chooses the filter for a stream. You can set a filter factory by calling the method ObjectInputFilter.Config.setSerialFilterFactory or specifying it in a system or Security property.">Setting a Filter Factory</a></li>
                     <li><a href="serialization-filtering1.html#GUID-80AD4DA1-6AA3-42C0-8172-DECF8FB8A841" title="The Java Remote Method Invocation (RMI) Registry, the RMI Distributed Garbage Collector, and Java Management Extensions (JMX) all have filters that are included in the JDK. You should specify your own filters for the RMI Registry and the RMI Distributed Garbage Collector to add additional protection.">Built-in Filters</a></li>
                     <li><a href="serialization-filtering1.html#GUID-6A048F49-052E-4591-9183-2775DC50831E" title="You can turn on logging to record the initialization, rejections, and acceptances of calls to serialization filters. Use the log output as a diagnostic tool to see what's being deserialized, and to confirm your settings when you configure allow-lists and reject-lists.">Logging Filter Actions</a></li>
                  </ul>
               </div>
               <!-- class="section" -->
            </div>
            <div class="sect2"><a id="GUID-55BABE96-3048-4A9F-A7E6-781790FF3480" name="GUID-55BABE96-3048-4A9F-A7E6-781790FF3480"></a><h3 id="JSCOR-GUID-55BABE96-3048-4A9F-A7E6-781790FF3480" class="sect3">Addressing Deserialization Vulnerabilities </h3>
               <div>
                  <p>An application that accepts untrusted data and deserializes it is vulnerable to attacks. You can create filters to screen incoming streams of serialized objects before they are deserialized. </p>
                  <div class="section">
                     <p class="subhead2" id="GUID-55BABE96-3048-4A9F-A7E6-781790FF3480__GUID-1B95D4FF-91B8-467C-962A-DB6EE59422AA">Inherent Dangers of
        Deserialization</p>
                     
                     
                     <p>Deserializing untrusted data, especially from an unknown, untrusted, or
        unauthenticated client, is an inherently dangerous activity because the content of the
        incoming data stream determines the objects that are created, the values of their fields,
        and the references between them. By careful construction of the stream, an adversary can run
        code in arbitrary classes with malicious intent.</p>
                     
                     <p>For example, if object construction has side effects that change state or
        invoke other actions, then those actions can compromise the integrity of application
        objects, library objects, and even the Java runtime. <span class="q">"Gadget classes,"</span> which can
        perform arbitrary reflective actions such as create classes and invoke methods on them, can
        be deserialized maliciously to cause a denial of service or remote code execution.
                     </p>
                     
                     <p>The key to disabling deserialization attacks is to prevent instances of
        arbitrary classes from being deserialized, thereby preventing the direct or indirect
        execution of their methods. You can do this through serialization filters.</p>
                     
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-55BABE96-3048-4A9F-A7E6-781790FF3480__GUID-49EB9201-2959-4036-AA1C-1990BF3E1BB3">Java Serialization and Deserialization
        Overview</p>
                     
                     
                     <p>An object is serialized when its state is converted to a byte stream. That
        stream can be sent to a file, to a database, or over a network. A Java object is
        serializable if its class or any of its superclasses implements either the <span class="apiname" translate="no">java.io.Serializable</span> interface or the <span class="apiname" translate="no">java.io.Externalizable</span> subinterface. In the JDK, serialization is used in many
        areas, including Remote Method Invocation (RMI), custom RMI for interprocess communication
        (IPC) protocols (such as the Spring HTTP invoker), and Java Management Extensions (JMX).
                     </p>
                     
                     <p>An object is deserialized when its serialized form is converted to a copy of
        the object. It is important to ensure the security of this conversion. Deserialization is
        code execution because the <span class="apiname" translate="no">readObject</span> method of the class
        that is being deserialized can contain custom code.
                     </p>
                     
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-55BABE96-3048-4A9F-A7E6-781790FF3480__GUID-5210884F-D15F-47E5-B2E0-8E5C5C86E82E">Serialization Filters</p>
                     
                     
                     <p>A serialization filter enables you to specify which classes are acceptable to
        an application and which should be rejected. Filters also enable you to control the object
        graph size and complexity during deserialization so that the object graph doesn’t exceed
        reasonable limits. You can configure filters as properties or implement them
        programmatically.</p>
                     
                     
                     <div class="infoboxnote" id="GUID-55BABE96-3048-4A9F-A7E6-781790FF3480__GUID-060645E8-00FE-44EA-B709-24863713B1D8">
                        <p class="notep1">Note:</p><span>A serialization filter
        is not enabled or configured by default. Serialization filtering doesn't occur unless you
        have specified the filter in a system property or a Security Property or set it with the
          <span class="apiname" translate="no">ObjectInputFilter</span> class.</span></div>
                     
                     <div class="p">Besides creating filters, you can take the following actions to help prevent
        deserialization vulnerabilities:
                        <ul style="list-style-type: disc;" id="GUID-55BABE96-3048-4A9F-A7E6-781790FF3480__UL_YP2_ZR4_1QB">
                           <li>Do not deserialize untrusted data.</li>
                           <li>Use SSL to encrypt and authenticate the connections between
            applications.</li>
                           <li>Validate field values before assignment, for example, checking object
            invariants by using the <span class="apiname" translate="no">readObject</span> method. 
                           </li>
                        </ul>
                     </div>
                     
                     <div class="infoboxnote" id="GUID-55BABE96-3048-4A9F-A7E6-781790FF3480__GUID-87B52F1C-9D44-483B-80AA-B2C8A4B0C06E">
                        <p class="notep1">Note:</p>Built-in filters are provided for RMI.
        However, you should use these built-in filters as starting points only. Configure
        reject-lists and/or extend the allow-list to add additional protection for your application
        that uses RMI. See <a href="serialization-filtering1.html#GUID-80AD4DA1-6AA3-42C0-8172-DECF8FB8A841" title="The Java Remote Method Invocation (RMI) Registry, the RMI Distributed Garbage Collector, and Java Management Extensions (JMX) all have filters that are included in the JDK. You should specify your own filters for the RMI Registry and the RMI Distributed Garbage Collector to add additional protection.">Built-in Filters</a>.
                     </div>
                     
                     <p>For more information about these and other strategies, see <span class="q">"Serialization and Deserialization"</span> in <a href="https://www.oracle.com/java/technologies/javase/seccodeguide.html" target="_blank">Secure Coding Guidelines for Java SE</a>.
                     </p>
                     
                  </div>
                  <!-- class="section" -->
               </div>
            </div>
            <div class="sect2"><a id="GUID-8296D8E8-2B93-4B9A-856E-0A65AF9B8C66" name="GUID-8296D8E8-2B93-4B9A-856E-0A65AF9B8C66"></a><h3 id="JSCOR-GUID-8296D8E8-2B93-4B9A-856E-0A65AF9B8C66" class="sect3">Java Serialization Filters</h3>
               <div>
                  <p>The Java serialization filtering mechanism screens incoming streams of
        serialized objects to help improve security and robustness. Filters can validate incoming
        instances of classes before they are deserialized.</p>
                  <div class="p">As stated in <a href="https://openjdk.java.net/jeps/290" target="_blank">JEP 290</a> and <a href="https://openjdk.java.net/jeps/415" target="_blank">JEP
                415</a>, the goals of the Java serialization filtering mechanism are to:
                     <ul style="list-style-type: disc;">
                        <li>
                           
                           <p>Provide a way to narrow the classes that can be deserialized
                        down to a context-appropriate set of classes.</p>
                           
                        </li>
                        <li>
                           
                           <p>Provide metrics to the filter for graph size and complexity
                        during deserialization to validate normal graph behaviors.</p>
                           
                        </li>
                        <li>
                           
                           <p>Allow RMI-exported objects to validate the classes expected in
                        invocations.</p>
                           
                        </li>
                     </ul>
                  </div>
                  <p>There are two kinds of filters:</p>
                  <ul style="list-style-type: disc;" id="GUID-8296D8E8-2B93-4B9A-856E-0A65AF9B8C66__UL_SXN_CGP_WPB">
                     <li><span class="bold">JVM-wide filter</span>: Is applied to every deserialization in the JVM.
                However, whether and how a JVM-wide filter validates classes in a particular
                deserialization depends on how it's combined with other filters.
                     </li>
                     <li><span class="bold">Stream-specific filter</span>: Validates classes from one specific
                    <code class="codeph">ObjectInputStream</code>.
                     </li>
                  </ul>
                  <p>You can implement a serialization filter in the following ways:</p>
                  <ul style="list-style-type: disc;">
                     <li>
                        <p><span class="bold">Specify a JVM-wide, pattern-based filter with the
                            <code class="codeph">jdk.serialFilter</code> property</span>: A pattern-based filter
                    consists of a sequence of patterns that can accept or reject the name of
                    specific classes, packages, or modules. It can place limits on array sizes,
                    graph depth, total references, and stream size. A typical use case is to add
                    classes that have been identified as potentially compromising the Java runtime
                    to a reject-list. If you specify a pattern-based filter with the
                        <code class="codeph">jdk.serialFilter</code> property, then you don't have to modify
                    your application. 
                        </p>
                     </li>
                     <li>
                        <p><span class="bold">Implement a custom or pattern-based stream-specific filter with the
                            <code class="codeph">ObjectInputFilter</code> API</span>: You can implement a filter
                    with the <span class="apiname" translate="no">ObjectInputFilter</span> API, which you then
                    set on an <span class="apiname" translate="no">ObjectInputStream</span>. You can create a
                    pattern-based filter with the <code class="codeph">ObjectInputFilter</code> API by calling
                    the <code class="codeph">Config.createFilter(String)</code> method.
                        </p>
                     </li>
                  </ul>
                  <div class="infoboxnote" id="GUID-8296D8E8-2B93-4B9A-856E-0A65AF9B8C66__GUID-4F57FFD1-D166-4299-8AD7-66884036FDF8">
                     <p class="notep1">Note:</p><span>A serialization filter
        is not enabled or configured by default. Serialization filtering doesn't occur unless you
        have specified the filter in a system property or a Security Property or set it with the
          <span class="apiname" translate="no">ObjectInputFilter</span> class.</span></div>
                  <p>For every new object in the stream, the filter mechanism applies only one filter to
            it. However, this filter might be a combination of filters.</p>
                  <p>In most cases, a stream-specific filter should check if a JVM-wide filter is set,
            especially if you haven't specified a filter factory. If a JVM-wide filter does exist,
            then the stream-specific filter should invoke it and use the JVM-wide filter’s result
            unless the status is <code class="codeph">UNDECIDED</code>.
                  </p>
               </div>
            </div>
            <div class="sect2"><a id="GUID-5456D226-396D-4916-8DB2-A13BB1BF49C1" name="GUID-5456D226-396D-4916-8DB2-A13BB1BF49C1"></a><h3 id="JSCOR-GUID-5456D226-396D-4916-8DB2-A13BB1BF49C1" class="sect3">Filter Factories</h3>
               <div>
                  <p></p>
                  <p>A filter factory selects, chooses, or combines filters into a single
                        filter to be used for a stream. When you specify one, a deserialization
                        operation uses it when it encounters a class for the first time to determine
                        whether to allow it. (Subsequent instances of the same class aren't
                        filtered.) It's implemented as a <span class="apiname" translate="no">BinaryOperator&lt;ObjectInputFilter&gt;</span> and specified
                        with the <span class="apiname" translate="no">ObjectInputFilter.Config.setSerialFilterFactory</span> method or
                        in a system or Security property; see <a href="serialization-filtering1.html#GUID-884D0115-2F99-4094-8499-4F25E37410F8" title="A filter factory is a BinaryOperator, which is a function of two operands that chooses the filter for a stream. You can set a filter factory by calling the method ObjectInputFilter.Config.setSerialFilterFactory or specifying it in a system or Security property.">Setting a Filter Factory</a>. Whenever an <span class="apiname" translate="no">ObjectInputStream</span> is created, the filter factory selects
                        an <span class="apiname" translate="no">ObjectInputFilter</span>. However, you can have
                        a different filter created based on the characteristics of the stream and
                        the filter that the filter factory previously created.
                  </p>
               </div>
            </div>
            <div class="sect2"><a id="GUID-952E2328-AB66-4412-8B6B-3BCCB3195C25" name="GUID-952E2328-AB66-4412-8B6B-3BCCB3195C25"></a><h3 id="JSCOR-GUID-952E2328-AB66-4412-8B6B-3BCCB3195C25" class="sect3">Allow-Lists and
        Reject-Lists</h3>
               <div>
                  <p>Allow-lists and reject-lists can be implemented using pattern-based filters
        or custom filters. These lists allow you to take proactive and defensive approaches to
        protect your applications. </p>
                  <p>The proactive approach uses allow-lists to allow only class names that are
            recognized and trusted and to reject all others. You can implement allow-lists in your
            code when you develop your application, or later by defining pattern-based filters. If
            your application only deals with a small set of classes then this approach can work very
            well. You can implement allow-lists by specifying the names of classes, packages, or
            modules that are allowed.</p>
                  <p>The defensive approach uses reject-lists to reject instances of classes that are not
            trusted. Usually, reject-lists are implemented after an attack that reveals that a class
            is a problem. A class name can be added to a reject-list, without a code change, by
            adding it to a pattern-based filter that's specified in the
                <code class="codeph">jdk.serialFilter</code> property.
                  </p>
               </div>
            </div>
            <div class="sect2"><a id="GUID-91735293-E38E-4A81-85DC-719AFEB36026" name="GUID-91735293-E38E-4A81-85DC-719AFEB36026"></a><h3 id="JSCOR-GUID-91735293-E38E-4A81-85DC-719AFEB36026" class="sect3">Creating Pattern-Based Filters</h3>
               <div>
                  <p>Pattern-based filters are filters that you define without changing your
        application code. You add JVM-wide filters in properties files or application-specific
        filters on the <code class="codeph">java</code> command line.
                  </p>
                  <p>A pattern-based filter is a sequence of patterns. Each pattern is matched against the name of a class in the stream or a resource limit. Class-based and resource limit patterns can be combined in one filter string, with each pattern separated by a semicolon (;). </p>
                  <div class="section">
                     <p class="subhead2" id="GUID-91735293-E38E-4A81-85DC-719AFEB36026__GUID-EC22FEC6-A855-4152-9049-23F38E590256">Pattern-based Filter Syntax</p>
                     <div class="p">When you create a filter that is composed of patterns, use the following guidelines:
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>Separate patterns by semicolons. For example:</p><pre class="pre codeblock"><code>pattern1.*;pattern2.*</code></pre></li>
                           <li>
                              <p>White space is significant and is considered part of the pattern.</p>
                           </li>
                           <li>
                              <p>Put the limits first in the string. They are evaluated first regardless of where they are in the string, so putting them first reinforces the ordering. Otherwise, patterns are evaluated from left to right.</p>
                           </li>
                           <li>
                              <div class="p">A class name that matches a pattern that is preceded by <code class="codeph">!</code> is
                            rejected. A class name that matches a pattern without <code class="codeph">!</code>
                            is allowed. The following filter rejects
                                <code class="codeph">pattern1.MyClass</code> but allows
                                <code class="codeph">pattern2.MyClass</code>:
                            <pre class="pre codeblock"><code>!pattern1.*;pattern2.*</code></pre></div>
                           </li>
                           <li>
                              <div class="p">Use the wildcard symbol (<code class="codeph">*</code>) to represent unspecified class names in
                            a pattern as shown in the following examples: 
                                 <ul style="list-style-type: disc;">
                                    <li>
                                       
                                       <p>To match every class name, use <code class="codeph">*</code>
                                          
                                       </p>
                                       
                                    </li>
                                    <li>
                                       
                                       <p>To match every class name in
                                            <code class="codeph">mypackage</code>, use
                                            <code class="codeph">mypackage.*</code>
                                          
                                       </p>
                                       
                                    </li>
                                    <li>
                                       
                                       <p>To match every class name in
                                            <code class="codeph">mypackage</code> and its subpackages, use
                                            <code class="codeph">mypackage.**</code></p>
                                       
                                    </li>
                                    <li>
                                       
                                       <p>To match every class name that starts with
                                            <code class="codeph">text</code>, use <code class="codeph">text*</code></p>
                                       
                                    </li>
                                 </ul>
                              </div>
                           </li>
                        </ul>
                     </div>
                     <p>If a class name doesn’t match any filter, then it is allowed. If you want to allow
                only certain class names, then your filter must reject everything that doesn’t
                match. To reject all class names other than those specified, include
                    <code class="codeph">!*</code> as the last pattern in a class filter.
                     </p>
                     <p>For a complete description of the syntax for the patterns, see <a href="http://openjdk.java.net/jeps/290" target="_blank">JEP
                    290</a>.
                     </p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-91735293-E38E-4A81-85DC-719AFEB36026__GUID-B3365B18-7AA0-4B9A-A305-DD22D21F0602">Pattern-Based Filter Limitations</p>
                     <p>The following are some of the limitations of pattern-based filters:</p>
                     <ul style="list-style-type: disc;">
                        <li>
                           <p>Patterns can’t allow different sizes of arrays based on the class name.</p>
                        </li>
                        <li>
                           <p>Patterns can’t match classes based on the supertype or interfaces of the class
                        name.</p>
                        </li>
                        <li>
                           <p>Patterns have no state and can’t make choices depending on the class instances
                        deserialized earlier in the stream.</p>
                        </li>
                     </ul>
                     
                     
                     <div class="infoboxnote" id="GUID-91735293-E38E-4A81-85DC-719AFEB36026__GUID-85837189-C1A1-44B5-ADFC-2721F42A7874">
                        <p class="notep1">Note:</p>A pattern-based filter doesn't
                check interfaces that are implemented by classes being deserialized. The filter is
                invoked for interfaces explicitly referenced in the stream; it isn't invoked for
                interfaces implemented by classes for objects being deserialized.
                     </div>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-91735293-E38E-4A81-85DC-719AFEB36026__GUID-5D6D5344-3E6F-468E-8CBB-05767E04B254">Define a Pattern-Based Filter for One Application</p>
                     <p>You can define a pattern-based filter as a system property for one application. A system property supersedes a Security Property value.</p>
                     <p>To create a filter that only applies to one application, and only to a single invocation of Java, define the <code class="codeph">jdk.serialFilter</code> system property in the command line. 
                     </p>
                     <p>The following example shows how to limit resource usage for an individual application:</p><pre class="pre codeblock"><code>java -Djdk.serialFilter=maxarray=100000;maxdepth=20;maxrefs=500&nbsp;com.example.test.Application</code></pre></div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-91735293-E38E-4A81-85DC-719AFEB36026__DEFINEAPATTERN-BASEDFILTERFORONEAPP-631AE055">Define a Pattern-Based Filter for All
                Applications</p>
                     <p>You can define a pattern-based, JVM-wide filter that affects every application run
                with a Java runtime from <code class="codeph">$JAVA_HOME</code> by specifying it as a Security
                Property. (Note that a system property supersedes a Security Property value.) Edit
                the file <code>$JAVA_HOME/conf/security/java.security</code> and add the
                pattern-based filter to the  <code class="codeph">jdk.serialFilter</code> Security
                Property.
                     </p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-91735293-E38E-4A81-85DC-719AFEB36026__GUID-5CE8B605-78A3-4B10-9DE8-5108EEB452A7">Define a Class Filter</p>
                     <p>You can create a pattern-based class filter that is applied globally. For example, the pattern might be a class name or a package with wildcard.</p>
                     <div class="p">In the following example, the filter rejects one class name from a package
                    (<code class="codeph">!example.somepackage.SomeClass</code>), and allows all other class
                names in the package:
                <pre class="pre codeblock"><code>jdk.serialFilter=!example.somepackage.SomeClass;example.somepackage.*;</code></pre></div>
                     <div class="p">The previous example filter allows all other class names, not just those in
                    <code class="codeph">example.somepackage.*</code>. To reject all other class names, add
                    <code class="codeph">!*</code>:<pre class="pre codeblock"><code>jdk.serialFilter=!example.somepackage.SomeClass;example.somepackage.*;<span class="bold">!*</span></code></pre></div>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-91735293-E38E-4A81-85DC-719AFEB36026__GUID-F0AE9610-1379-44D6-A051-8F67E5522065">Define a Resource Limit Filter</p>
                     <div class="p">A resource filter limits graph complexity and size. You can create filters for the following parameters to control the resource usage for each application:
                        <ul style="list-style-type: disc;">
                           <li>
                              <p>Maximum allowed array size. For example: <code class="codeph">maxarray=100000;</code> 
                              </p>
                           </li>
                           <li>
                              <p>Maximum depth of a graph. For example: <code class="codeph">maxdepth=20;</code> 
                              </p>
                           </li>
                           <li>
                              <p>Maximum references in a graph between objects. For example: <code class="codeph">maxrefs=500;</code> 
                              </p>
                           </li>
                           <li>
                              <p>Maximum number of bytes in a stream. For example: <code class="codeph">maxbytes=500000;</code> 
                              </p>
                           </li>
                        </ul>
                     </div>
                  </div>
                  <!-- class="section" -->
               </div>
            </div>
            <div class="sect2"><a id="GUID-0A1D23AB-2F18-4979-9288-9CFEC04F207E" name="GUID-0A1D23AB-2F18-4979-9288-9CFEC04F207E"></a><h3 id="JSCOR-GUID-0A1D23AB-2F18-4979-9288-9CFEC04F207E" class="sect3">Creating Custom Filters</h3>
               <div>
                  <p>Custom filters are filters you specify in your application’s code. They are set on an individual stream or on all streams in a process. You can implement a custom filter as a pattern, a method, a lambda expression, or a class.</p>
                  <div class="section">
                     <p class="subhead2" id="GUID-0A1D23AB-2F18-4979-9288-9CFEC04F207E__GUID-81948BE2-103E-45A6-8F4C-25A4694038E6">Topics</p>
                     
                     
                     <ul style="list-style-type: disc;" id="GUID-0A1D23AB-2F18-4979-9288-9CFEC04F207E__UL_VJN_Y2F_MQB">
                        <li><a href="serialization-filtering1.html#GUID-304C4F2F-6303-42E9-83CD-F1E723B56461" title="You can set a custom filter on one ObjectInputStream, or, to apply the same filter to every stream, set a JVM-wide filter. If an ObjectInputStream doesn’t have a filter defined for it, the JVM-wide filter is called, if there is one.">Reading a Stream of Serialized Objects</a></li>
                        <li><a href="serialization-filtering1.html#GUID-5836181D-8B29-431E-A4FE-9963190B8F18" title="You can set a filter on an individual ObjectInputStream when the input to the stream is untrusted and the filter has a limited set of classes or constraints to enforce. For example, you could ensure that a stream only contains numbers, strings, and other application-specified types.">Setting a Custom Filter for an Individual Stream</a></li>
                        <li><a href="serialization-filtering1.html#GUID-25E1FBE7-890A-4232-ACB9-68C39968F13A" title="You can set a JVM-wide filter that applies to every use of ObjectInputStream unless it is overridden on a specific stream. If you can identify every type and condition that is needed by the entire application, the filter can allow those and reject the rest. Typically, JVM-wide filters are used to reject specific classes or packages, or to limit array sizes, graph depth, or total graph size.">Setting a JVM-Wide Custom Filter</a></li>
                        <li><a href="serialization-filtering1.html#GUID-E5FBFAB0-FB8B-443C-9841-C67080A5DA03" title="A pattern-based custom filter, which is convenient for simple cases, can be created by using the ObjectInputFilter.Config.createFilter method. You can create a pattern-based filter as a system property or Security Property. Implementing a pattern-based filter as a method or a lambda expression gives you more flexibility.">Setting a Custom Filter Using a Pattern</a></li>
                        <li><a href="serialization-filtering1.html#GUID-46BF55A3-531F-42FD-B762-2781C62D1A44" title="A custom filter can be implemented as a class implementing the java.io.ObjectInputFilter interface, as a lambda expression, or as a method.">Setting a Custom Filter as a Class</a></li>
                        <li><a href="serialization-filtering1.html#GUID-BFDC445A-015B-4E06-9F76-EA700CB346F1" title="A custom filter can also be implemented as a method. The method reference is used instead of an inline lambda expression.">Setting a Custom Filter as a Method</a></li>
                        <li><a href="serialization-filtering1.html#GUID-19B2839D-D308-4044-9682-3FD89F558CD1" title="The ObjectInputFilter interface includes the following static methods that enable you to quickly create filters:">Creating a Filter with ObjectInputFilter Methods</a></li>
                     </ul>
                     
                  </div>
                  <!-- class="section" -->
               </div>
               <div class="sect3"><a id="GUID-304C4F2F-6303-42E9-83CD-F1E723B56461" name="GUID-304C4F2F-6303-42E9-83CD-F1E723B56461"></a><h4 id="JSCOR-GUID-304C4F2F-6303-42E9-83CD-F1E723B56461" class="sect4">Reading a Stream of Serialized
        Objects</h4>
                  <div>
                     <p>You can set a custom filter on one <code class="codeph">ObjectInputStream</code>, or, to
        apply the same filter to every stream, set a JVM-wide filter. If an
            <code class="codeph">ObjectInputStream</code> doesn’t have a filter defined for it, the JVM-wide
        filter is called, if there is one.
                     </p>
                     <p>While the stream is being decoded, the following actions occur:</p>
                     <ul style="list-style-type: disc;" id="GUID-304C4F2F-6303-42E9-83CD-F1E723B56461__UL_D2D_MYJ_3QB">
                        <li>For each new object in the stream and before the object is instantiated
                and deserialized, the filter is called when it encounters a class for the first
                time. (Subsequent instances of the same class aren't filtered.)</li>
                        <li>For each class in the stream, the filter is called with the resolved
                class. It is called separately for each supertype and interface in the stream. </li>
                        <li>The filter can examine each class referenced in the stream, including
                the class of objects to be created, supertypes of those classes, and their
                interfaces.</li>
                        <li>For each array in the stream, whether it is an array of primitives,
                array of strings, or array of objects, the filter is called with the array class and
                the array length.</li>
                        <li>For each reference to an object already read from the stream, the
                filter is called so it can check the depth, number of references, and stream length.
                The depth starts at&nbsp;1&nbsp;and increases for each nested object and decreases when each
                nested call returns.</li>
                        <li>The filter is not called for primitives or for <span class="apiname" translate="no">java.lang.String</span> instances that are encoded concretely in the stream. 
                        </li>
                        <li>The filter returns a status of accept, reject, or undecided.</li>
                        <li>Filter actions are logged if logging is enabled.</li>
                     </ul>
                     <p>Unless a filter rejects the object, the object is accepted.</p>
                  </div>
               </div>
               <div class="sect3"><a id="GUID-5836181D-8B29-431E-A4FE-9963190B8F18" name="GUID-5836181D-8B29-431E-A4FE-9963190B8F18"></a><h4 id="JSCOR-GUID-5836181D-8B29-431E-A4FE-9963190B8F18" class="sect4">Setting a Custom Filter for an
        Individual Stream</h4>
                  <div>
                     <p>You can set a filter on an individual <span class="apiname" translate="no">ObjectInputStream</span> when the input to the stream is untrusted and the filter
        has a limited set of classes or constraints to enforce. For example, you could ensure that a
        stream only contains numbers, strings, and other application-specified types.
                     </p>
                     <p>A custom filter is set using the <span class="apiname" translate="no">setObjectInputFilter​</span> method. The custom filter must be set before
            objects are read from the stream.
                     </p>
                     <p>In the following example, the <span class="apiname" translate="no">setObjectInputFilter</span> method is invoked with the
                <code class="codeph">dateTimeFilter</code> method. This filter only accepts classes from the
                <span class="apiname" translate="no">java.time</span> package. The
                <code class="codeph">dateTimeFilter</code> method is defined in a code sample in <a href="serialization-filtering1.html#GUID-BFDC445A-015B-4E06-9F76-EA700CB346F1" title="A custom filter can also be implemented as a method. The method reference is used instead of an inline lambda expression.">Setting a Custom Filter as a Method</a>.
                     </p>
                     <div class="p">
                        <pre class="pre codeblock"><code>    LocalDateTime readDateTime(InputStream is) throws IOException {
        try (ObjectInputStream ois = new ObjectInputStream(is)) {
            ois.setObjectInputFilter(FilterClass::dateTimeFilter);
            return (LocalDateTime) ois.readObject();
        } catch (ClassNotFoundException ex) {
            IOException ioe = new StreamCorruptedException("class missing");
            ioe.initCause(ex);
            throw ioe;
        }
    }</code></pre>
                        </div>
                  </div>
               </div>
               <div class="sect3"><a id="GUID-25E1FBE7-890A-4232-ACB9-68C39968F13A" name="GUID-25E1FBE7-890A-4232-ACB9-68C39968F13A"></a><h4 id="JSCOR-GUID-25E1FBE7-890A-4232-ACB9-68C39968F13A" class="sect4">Setting a JVM-Wide Custom
        Filter</h4>
                  <div>
                     <p>You can set a JVM-wide filter that applies to every use of <span class="apiname" translate="no">ObjectInputStream</span> unless it is overridden on a specific stream.
        If you can identify every type and condition that is needed by the entire application, the
        filter can allow those and reject the rest. Typically, JVM-wide filters are used to reject
        specific classes or packages, or to limit array sizes, graph depth, or total graph
        size.
                     </p>
                     <p>A JVM-wide filter is set once using the methods of the <span class="apiname" translate="no">ObjectInputFilter.Config</span> class. The filter can be an instance of a class,
            a lambda expression, a method reference, or a pattern.
                     </p><pre class="pre codeblock"><code>ObjectInputFilter filter = ...
ObjectInputFilter.Config.setSerialFilter(filter);</code></pre><p>In the following example, the JVM-wide filter is set by using a lambda
            expression.</p><pre class="pre codeblock"><code>ObjectInputFilter.Config.setSerialFilter(
    info -&gt; info.depth() &gt; 10 ? Status.REJECTED : Status.UNDECIDED);</code></pre><p>In the following example, the JVM-wide filter is set by using a method
            reference:</p><pre class="pre codeblock"><code>ObjectInputFilter.Config.setSerialFilter(FilterClass::dateTimeFilter);</code></pre></div>
               </div>
               <div class="sect3"><a id="GUID-E5FBFAB0-FB8B-443C-9841-C67080A5DA03" name="GUID-E5FBFAB0-FB8B-443C-9841-C67080A5DA03"></a><h4 id="JSCOR-GUID-E5FBFAB0-FB8B-443C-9841-C67080A5DA03" class="sect4">Setting a Custom Filter Using a
        Pattern</h4>
                  <div>
                     <p>A pattern-based custom filter, which is convenient for simple cases, can be
        created by using the <span class="apiname" translate="no">ObjectInputFilter.Config.createFilter</span>
        method. You can create a pattern-based filter as a system property or Security Property.
        Implementing a pattern-based filter as a method or a lambda expression gives you more
        flexibility.
                     </p>
                     <p>The filter patterns can accept or reject specific names of classes, packages,
            and modules and can place limits on array sizes, graph depth, total references, and
            stream size. Patterns cannot match the names of the supertype or interfaces of the
            class.</p>
                     <div class="p">In the following example, the filter allows <code class="codeph">example.File</code> and
            rejects
            <code class="codeph">example.Directory</code>.<pre class="pre codeblock"><code>ObjectInputFilter filesOnlyFilter =
    ObjectInputFilter.Config.createFilter("example.File;!example.Directory");</code></pre></div>
                     <div class="p">This example allows only <code class="codeph">example.File</code>. All other class names
            are
            rejected.<pre class="pre codeblock"><code>ObjectInputFilter filesOnlyFilter =
    ObjectInputFilter.Config.createFilter("example.File;!*");</code></pre></div>
                  </div>
               </div>
               <div class="sect3"><a id="GUID-46BF55A3-531F-42FD-B762-2781C62D1A44" name="GUID-46BF55A3-531F-42FD-B762-2781C62D1A44"></a><h4 id="JSCOR-GUID-46BF55A3-531F-42FD-B762-2781C62D1A44" class="sect4">Setting a Custom Filter as a
        Class</h4>
                  <div>
                     <p>A custom filter can be implemented as a class implementing the <span class="apiname" translate="no">java.io.ObjectInputFilter</span> interface, as a lambda expression, or
        as a method.
                     </p>
                     <p>A filter is typically stateless and performs checks solely on the input
            parameters.&nbsp; However, you may implement a filter that, for example, maintains state
            between calls to the <code class="codeph">checkInput</code> method to count artifacts in the
            stream.
                     </p>
                     <p>In the following example, the <code class="codeph">FilterNumber</code> class allows any
            object that is an instance of the <code class="codeph">Number</code> class and rejects all
            others.
                     </p><pre class="pre codeblock"><code>    class FilterNumber implements ObjectInputFilter {
        public Status checkInput(FilterInfo filterInfo) {
            Class&lt;?&gt; clazz = filterInfo.serialClass();
            if (clazz != null) {
                return (Number.class.isAssignableFrom(clazz))
                    ? ObjectInputFilter.Status.ALLOWED
                    : ObjectInputFilter.Status.REJECTED;
            }
            return ObjectInputFilter.Status.UNDECIDED;
        }
    }</code></pre><p>In the example:</p>
                     <ul style="list-style-type: disc;" id="GUID-46BF55A3-531F-42FD-B762-2781C62D1A44__UL_T2R_4ZJ_3QB">
                        <li>The <code class="codeph">checkInput</code> method accepts an
                    <code class="codeph">ObjectInputFilter.FilterInfo</code> object.&nbsp;The object’s methods
                provide access to the class to be checked, array size, current depth, number of
                references to existing objects, and stream size read so far.
                        </li>
                        <li>If <code class="codeph">serialClass</code> is not null, then the value is checked
                to see if the class of the object is <code class="codeph">Number</code>. If so, it is accepted
                and returns <code class="codeph">ObjectInputFilter.Status.ALLOWED</code>. Otherwise, it is
                rejected and returns <code class="codeph">ObjectInputFilter.Status.REJECTED</code>.
                        </li>
                        <li>Any other combination of arguments returns
                    <code class="codeph">ObjectInputFilter.Status.UNDECIDED</code>. Deserialization continues,
                and any remaining filters are run until the object is accepted or rejected. If there
                are no other filters, the object is accepted.
                        </li>
                     </ul>
                  </div>
               </div>
               <div class="sect3"><a id="GUID-BFDC445A-015B-4E06-9F76-EA700CB346F1" name="GUID-BFDC445A-015B-4E06-9F76-EA700CB346F1"></a><h4 id="JSCOR-GUID-BFDC445A-015B-4E06-9F76-EA700CB346F1" class="sect4">Setting a Custom Filter as a
        Method</h4>
                  <div>
                     <p>A custom filter can also be implemented as a method. The method reference is
        used instead of an inline lambda expression.</p>
                     <p>The <code class="codeph">dateTimeFilter</code> method that is defined in the following
            example is used by the code sample in <a href="serialization-filtering1.html#GUID-5836181D-8B29-431E-A4FE-9963190B8F18" title="You can set a filter on an individual ObjectInputStream when the input to the stream is untrusted and the filter has a limited set of classes or constraints to enforce. For example, you could ensure that a stream only contains numbers, strings, and other application-specified types.">Setting a Custom Filter for an Individual Stream</a>.
                     </p><pre class="pre codeblock"><code>    public class FilterClass {
        static ObjectInputFilter.Status dateTimeFilter(ObjectInputFilter.FilterInfo info) {
            Class&lt;?&gt; serialClass = info.serialClass();
            if (serialClass != null) {
                return serialClass.getPackageName().equals("java.time")
                        ? ObjectInputFilter.Status.ALLOWED
                        : ObjectInputFilter.Status.REJECTED;
            }
            return ObjectInputFilter.Status.UNDECIDED;
        }
    }</code></pre><p>This custom filter allows only the classes found in the base module of the
            JDK:</p><pre class="pre codeblock"><code>        static ObjectInputFilter.Status baseFilter(ObjectInputFilter.FilterInfo info) {
            Class&lt;?&gt; serialClass = info.serialClass();
            if (serialClass != null) {
                return serialClass.getModule().getName().equals("java.base")
                        ? ObjectInputFilter.Status.ALLOWED
                        : ObjectInputFilter.Status.REJECTED;
            }
            return ObjectInputFilter.Status.UNDECIDED;
       }</code></pre></div>
               </div>
               <div class="sect3"><a id="GUID-19B2839D-D308-4044-9682-3FD89F558CD1" name="GUID-19B2839D-D308-4044-9682-3FD89F558CD1"></a><h4 id="JSCOR-GUID-19B2839D-D308-4044-9682-3FD89F558CD1" class="sect4">Creating a Filter with
        ObjectInputFilter Methods</h4>
                  <div>
                     <p>The <code class="codeph">ObjectInputFilter</code> interface includes the following
        static methods that enable you to quickly create filters:
                     </p>
                     <ul style="list-style-type: disc;" id="GUID-19B2839D-D308-4044-9682-3FD89F558CD1__UL_WMJ_GJQ_WPB">
                        <li><span class="apiname" translate="no">allowFilter(Predicate&lt;Class&lt;?&gt;&gt;,
                    ObjectInputFilter.Status)</span></li>
                        <li><span class="apiname" translate="no">rejectFilter(Predicate&lt;Class&lt;?&gt;&gt;,
                    ObjectInputFilter.Status)</span></li>
                        <li><span class="apiname" translate="no">rejectUndecidedClass(ObjectInputFilter)</span></li>
                        <li><span class="apiname" translate="no">merge(ObjectInputFilter,
                    ObjectInputFilter)</span></li>
                     </ul>
                     <p>The <span class="apiname" translate="no">allowFilter</span> method creates a filter based
            on a <code class="codeph">Predicate</code> that takes a <code class="codeph">Class</code> as its argument. The
            created filter returns <code class="codeph">ObjectInputFilter.Status.ALLOWED</code> if the
            predicate is true. Otherwise, it returns the value of the <code class="codeph">allowFilter</code>
            method’s second argument. The following creates a filter that accepts the
                <code class="codeph">Integer</code> class. All other classes are considered undecided:
                     </p><pre class="pre codeblock"><code>ObjectInputFilter intFilter = ObjectInputFilter.allowFilter(
    cl -&gt; cl.equals(Integer.class), ObjectInputFilter.Status.UNDECIDED);</code></pre><p>The <span class="apiname" translate="no">rejectFilter</span> method is the inverse of
                <code class="codeph">allowFilter</code>: It creates a filter based on a <span class="apiname" translate="no">Predicate</span> that takes a <span class="apiname" translate="no">Class</span> as its
            argument. The created filter returns <span class="apiname" translate="no">ObjectInputFilter.Status.REJECTED</span> if the predicate is true. Otherwise, it
            returns the value of the <span class="apiname" translate="no">rejectFilter</span> method’s second
            argument. The following creates a filter that rejects any class loaded from the
            application class loader:
                     </p><pre class="pre codeblock"><code>ObjectInputFilter f = ObjectInputFilter.rejectFilter(cl -&gt;
    cl.getClassLoader() == ClassLoader.getSystemClassLoader(), Status.UNDECIDED);</code></pre><p>The <code class="codeph">rejectUndecidedClass</code> method creates a new filter based
            on an existing filter by rejecting any class that the existing filter considers as
            undecided. The following creates a filter based on <code class="codeph">intFilter</code>. It
            accepts the <code class="codeph">Integer</code> class but rejects all other (undecided) classes: 
                     </p><pre class="pre codeblock"><code>ObjectInputFilter rejectUndecidedFilter =
    ObjectInputFilter.rejectUndecidedClass(intFilter);</code></pre><p>The <code class="codeph">merge</code> method creates a new filter by merging two
            filters. The following merges the filters <code class="codeph">intFilter</code> and
                <code class="codeph">f</code>. It accepts the <code class="codeph">Integer</code> class but rejects any
            class loaded from the application class loader:
                     </p><pre class="pre codeblock"><code>ObjectInputFilter mergedFilter = ObjectInputFilter.merge(intFilter, f);</code></pre><p>A merged filter follows these steps when it filters a class:</p>
                     <ol id="GUID-19B2839D-D308-4044-9682-3FD89F558CD1__OL_PCQ_RQV_1QB">
                        <li>Return <span class="apiname" translate="no">Status.REJECTED</span> if either of its
                filters return <span class="apiname" translate="no">Status.REJECTED</span>.
                        </li>
                        <li>Return <span class="apiname" translate="no">Status.ACCEPTED</span> if either of its
                filters return <span class="apiname" translate="no">Status.ACCEPTED</span>.
                        </li>
                        <li>Return <span class="apiname" translate="no">Status.UNDECIDED</span> (both of its
                filters return <span class="apiname" translate="no">Status.UNDECIDED</span>).
                        </li>
                     </ol>
                     <p>The <code class="codeph">merge</code> method is useful in filter factories. Every time
            a filter is set on a stream, you can append that filter to the one that the filter
            factory creates with the <code class="codeph">merge</code> method. See the <a href="../docs/api/java.base/java/io/ObjectInputFilter.html" target="_blank"><span class="apiname" translate="no">ObjectInputFilter</span></a>
            API documentation for an example.
                     </p>
                     <div class="infoboxnote" id="GUID-19B2839D-D308-4044-9682-3FD89F558CD1__GUID-8E34860B-8344-4C62-AFAC-069D9A6C7AF2">
                        <p class="notep1">Note:</p>It's a good idea to merge the JVM-wide
            filter with the requested, stream-specific filter in your filter factory. If you just
            return the requested filter, then you effectively disable the JVM-wide filter, which
            will lead to security gaps.
                     </div>
                  </div>
               </div>
            </div>
            <div class="sect2"><a id="GUID-884D0115-2F99-4094-8499-4F25E37410F8" name="GUID-884D0115-2F99-4094-8499-4F25E37410F8"></a><h3 id="JSCOR-GUID-884D0115-2F99-4094-8499-4F25E37410F8" class="sect3">Setting a Filter Factory</h3>
               <div>
                  <p>A filter factory is a <span class="apiname" translate="no">BinaryOperator</span>, which
        is a function of two operands that chooses the filter for a stream. You can set a filter
        factory by calling the method <span class="apiname" translate="no">ObjectInputFilter.Config.setSerialFilterFactory</span> or specifying it in a system
        or Security property.
                  </p>
                  <div class="infoboxnote" id="GUID-884D0115-2F99-4094-8499-4F25E37410F8__GUID-D69FFE8F-4EFD-4BD0-AADE-698E9097DA8D">
                     <p class="notep1">Note:</p>You can set a filter factory exactly
                        once, either with the method <span class="apiname" translate="no">setSerialFilterFactory</span>, in the system property
                                <code class="codeph">jdk.serialFilterFactory</code>, or in the Security
                        Property <code class="codeph">jdk.serialFilterFactory</code>.
                  </div>
                  <div class="section">
                     <p class="subhead2" id="GUID-884D0115-2F99-4094-8499-4F25E37410F8__GUID-AFB6B764-8908-4850-86E4-F183C4FDCDD8">Topics:</p>
                     
                     
                     <ul style="list-style-type: disc;" id="GUID-884D0115-2F99-4094-8499-4F25E37410F8__UL_LVX_ZGL_3QB">
                        <li><a href="serialization-filtering1.html#GUID-6995FF12-B1EE-4B4B-B4CD-AFE8A010E2DB" title="When you set a filter factory by calling the method ObjectInputFilter.Config.setSerialFilterFactory, the filter factory's method BinaryOperator<ObjectInputFilter&gt;.apply(ObjectInputFilter t, ObjectInputFilter u) will be invoked when an ObjectInputStream is constructed and when a stream-specific filter is set on an ObjectInputStream. The parameter t is the current filter and u is the requested filter. When apply is first invoked, t will be null. If a JVM-wide filter has been set, then when apply is first invoked, u will be the JVM-wide filter. Otherwise, u will be null. The apply method (which you must implement yourself) returns the filter to be used for the stream. If apply is invoked again, then the parameter t will be this returned filter. When you set a filter with the method ObjectInputStream.setObjectInputFilter(ObjectInputFilter), then parameter u will be this filter.">Setting a Filter Factory with setSerialFilterFactory</a></li>
                        <li><a href="serialization-filtering1.html#GUID-5FBD7364-6C84-44DB-8C2D-EDC437B6798D" title="You can set a filter factory that applies to only one application and to only a single invocation of Java by specifying it in the jdk.serialFilterFactory system property in the command line:">Specifying a Filter Factory in a System or Security Property</a></li>
                     </ul>
                     
                  </div>
                  <!-- class="section" -->
               </div>
               <div class="sect3"><a id="GUID-6995FF12-B1EE-4B4B-B4CD-AFE8A010E2DB" name="GUID-6995FF12-B1EE-4B4B-B4CD-AFE8A010E2DB"></a><h4 id="JSCOR-GUID-6995FF12-B1EE-4B4B-B4CD-AFE8A010E2DB" class="sect4">Setting a Filter Factory with
        setSerialFilterFactory</h4>
                  <div>
                     <p>When you set a filter factory by calling the method <span class="apiname" translate="no">ObjectInputFilter.Config.setSerialFilterFactory</span>, the filter factory's method
            <code class="codeph">BinaryOperator&lt;ObjectInputFilter&gt;.apply(ObjectInputFilter t,
            ObjectInputFilter u)</code> will be invoked when an <code class="codeph">ObjectInputStream</code>
        is constructed and when a stream-specific filter is set on an
            <code class="codeph">ObjectInputStream</code>. The parameter <code class="codeph">t</code> is the current
        filter and <code class="codeph">u</code> is the requested filter. When <span class="apiname" translate="no">apply</span> is first invoked, <code class="codeph">t</code> will be null. If a JVM-wide filter
        has been set, then when <span class="apiname" translate="no">apply</span> is first invoked,
            <code class="codeph">u</code> will be the JVM-wide filter. Otherwise, <code class="codeph">u</code> will be
        null. The <span class="apiname" translate="no">apply</span> method (which you must implement yourself)
        returns the filter to be used for the stream. If <span class="apiname" translate="no">apply</span> is
        invoked again, then the parameter <code class="codeph">t</code> will be this returned filter. When you
        set a filter with the method <span class="apiname" translate="no">ObjectInputStream.setObjectInputFilter(ObjectInputFilter)</span>, then parameter
            <code class="codeph">u</code> will be this filter. 
                     </p>
                     <p>The following example implements a simple filter factory that prints its
                <span class="apiname" translate="no">ObjectInputFilter</span> parameters every time its
                <code class="codeph">apply</code> method is invoked, merges these parameters into one combined
            filter, then returns this merged filter.
                     </p><pre class="pre codeblock"><code>public class SimpleFilterFactory {

    static class MySimpleFilterFactory implements BinaryOperator&lt;ObjectInputFilter&gt; {
        public ObjectInputFilter apply(
            ObjectInputFilter curr, ObjectInputFilter next) {
            System.out.println("Current filter: " + curr);
            System.out.println("Requested filter: " + next);
            return ObjectInputFilter.merge(next, curr);
        }
    }            
   
    private static byte[] createSimpleStream(Object obj) {
        ByteArrayOutputStream boas = new ByteArrayOutputStream();
        try (ObjectOutputStream ois = new ObjectOutputStream(boas)) {
            ois.writeObject(obj);
            return boas.toByteArray();
        } catch (IOException ioe) {
            ioe.printStackTrace();
        }
        throw new RuntimeException();        
    }
            
    public static void main(String[] args) throws IOException {
        
        // Set a filter factory
        
        MySimpleFilterFactory contextFilterFactory = new MySimpleFilterFactory();
        ObjectInputFilter.Config.setSerialFilterFactory(contextFilterFactory);          
        
        // Set a stream-specific filter
        
        ObjectInputFilter filter1 =
            ObjectInputFilter.Config.createFilter("example.*;java.base/*;!*");
        ObjectInputFilter.Config.setSerialFilter(filter1);

        // Create another filter        
        
        ObjectInputFilter intFilter = ObjectInputFilter.allowFilter(
          cl -&gt; cl.equals(Integer.class), ObjectInputFilter.Status.UNDECIDED);        
          
        // Create input stream
          
        byte[] intByteStream = createSimpleStream(42);
        InputStream is = new ByteArrayInputStream(intByteStream);
        ObjectInputStream ois = new ObjectInputStream(is);
        ois.setObjectInputFilter(intFilter);
        
        try {
            Object obj = ois.readObject();
            System.out.println("Read obj: " + obj);
        } catch (ClassNotFoundException e) {
            e.printStackTrace();
        }
    }
}</code></pre><p>This example prints output similar to the following (line breaks have been
            added for clarity):</p><pre class="pre codeblock"><code>Current filter: null
Requested filter: example.*;java.base/*;!*
Current filter: example.*;java.base/*;!*
Requested filter:
    merge(
        predicate(
            SimpleFilterFactory$$Lambda$8/0x0000000800c00c60@76ed5528,
            ifTrue: ALLOWED, ifFalse: UNDECIDED),
        predicate(
            SimpleFilterFactory$$Lambda$9/0x0000000800c01800@2c7b84de,
            ifTrue: REJECTED, ifFalse: UNDECIDED))
Read obj: 42</code></pre><p>The <code class="codeph">apply</code> method is invoked twice: when the <span class="apiname" translate="no">ObjectInputStream</span>
                        <code class="codeph">ois</code> is created and when the method
                <code class="codeph">setObjectInputFilter</code> is called.
                     </p>
                     <div class="infoboxnote" id="GUID-6995FF12-B1EE-4B4B-B4CD-AFE8A010E2DB__GUID-21E04B99-9B97-4D50-A02F-876C86D7D695">
                        <p class="notep1">Note:</p>
                        
                        <ul style="list-style-type: disc;" id="GUID-6995FF12-B1EE-4B4B-B4CD-AFE8A010E2DB__UL_ICQ_2NV_1QB">
                           <li>You can set a filter on an <span class="apiname" translate="no">ObjectInputStream</span> only once. An
                        <code class="codeph">IllegalStateException</code> will be thrown otherwise.
                           </li>
                           <li>To protect against unexpected deserializations, ensure that
                    security experts thoroughly review how your filter factories select and combine
                    filters.</li>
                        </ul>
                        
                     </div>
                  </div>
               </div>
               <div class="sect3"><a id="GUID-5FBD7364-6C84-44DB-8C2D-EDC437B6798D" name="GUID-5FBD7364-6C84-44DB-8C2D-EDC437B6798D"></a><h4 id="JSCOR-GUID-5FBD7364-6C84-44DB-8C2D-EDC437B6798D" class="sect4">Specifying a Filter Factory in a
        System or Security Property</h4>
                  <div>
                     <p>You can set a filter factory that applies to only one application and to only
        a single invocation of Java by specifying it in the <code class="codeph">jdk.serialFilterFactory</code>
        system property in the command line:
                     </p>
                     <p><code class="codeph">java -Djdk.serialFilterFactory=<span class="variable" translate="no">FilterFactoryClassName</span>
                           <span class="variable" translate="no">YourApplication</span></code></p>
                     <p>The value of <code class="codeph">jdk.serialFilterFactory</code> is the class name of
            the filter factory to be set before the first deserialization. The class must be public
            and accessible to the application class loader (which the method <a href="../docs/api/java.base/java/lang/ClassLoader.html#getSystemClassLoader()" target="_blank"><span class="apiname" translate="no">java.lang.ClassLoader.getSystemClassLoader()</span></a>
            returns).
                     </p>
                     <p>You can set a JVM-wide filter factory that affects every application run
            with a Java runtime from <code class="codeph">$JAVA_HOME</code> by specifying it in a Security
            Property. Note that a system property supersedes a Security Property value. Edit the
            file <code>$JAVA_HOME/conf/security/java.security</code> and specify the filter
            factory's class name in the <code class="codeph">jdk.serialFilterFactory</code> Security
            Property.
                     </p>
                  </div>
               </div>
            </div>
            <div class="sect2"><a id="GUID-80AD4DA1-6AA3-42C0-8172-DECF8FB8A841" name="GUID-80AD4DA1-6AA3-42C0-8172-DECF8FB8A841"></a><h3 id="JSCOR-GUID-80AD4DA1-6AA3-42C0-8172-DECF8FB8A841" class="sect3">Built-in Filters</h3>
               <div>
                  <p>The Java Remote Method Invocation (RMI) Registry, the RMI Distributed Garbage Collector, and Java Management Extensions (JMX) all have filters that are included in the JDK. You should specify your own filters for the RMI Registry and the RMI Distributed Garbage Collector to add additional protection.</p>
                  <div class="section">
                     <p class="subhead2" id="GUID-80AD4DA1-6AA3-42C0-8172-DECF8FB8A841__GUID-4A6545F6-C1BA-4F4B-B5FB-1A0FFC17EE58">Filters for RMI Registry</p>
                     <div class="infoboxnote" id="GUID-80AD4DA1-6AA3-42C0-8172-DECF8FB8A841__GUID-2EDDE4F4-6635-4724-BE9B-E250436F23AE">
                        <p class="notep1">Note:</p>Use these built-in filters as starting points
                                                  only. Edit the
                                                  <code class="codeph">sun.rmi.registry.registryFilter</code>
                                                  system property to configure reject-lists and/or
                                                  extend the allow-list to add additional protection
                                                  for the RMI Registry. To protect the whole
                                                  application, add the patterns to the
                                                  <code class="codeph">jdk.serialFilter</code> global system
                                                  property to increase protection for other
                                                  serialization users that do not have their own
                                                  custom filters.
                     </div>
                     <p>The RMI Registry has a built-in allow-list filter that allows objects to be bound in
                the registry. It includes instances of the <code class="codeph">java.rmi.Remote</code>,
                    <code class="codeph">java.lang.Number</code>, <code class="codeph">java.lang.reflect.Proxy</code>,
                    <code class="codeph">java.rmi.server.UnicastRef</code>,
                    <code class="codeph">java.rmi.server.UID</code>,
                    <code class="codeph">java.rmi.server.RMIClientSocketFactory</code>, and
                    <code class="codeph">java.rmi.server.RMIServerSocketFactory</code> classes.
                     </p>
                     <div class="p">The built-in filter includes size
                limits:&nbsp;<pre class="pre codeblock"><code> maxarray=1000000;maxdepth=20</code></pre></div>
                     <p>Supersede the built-in filter by defining a filter using the <code class="codeph">sun.rmi.registry.registryFilter</code> system property with a pattern. If the filter that you define either accepts classes passed to the filter, or rejects classes or sizes, the built-in filter is not invoked.&nbsp; If your filter does not accept or reject anything, the built-filter is invoked.
                     </p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-80AD4DA1-6AA3-42C0-8172-DECF8FB8A841__GUID-1FA9EA68-C15E-4D08-B938-368EB4B3CF58">Filters for RMI Distributed Garbage Collector</p>
                     <div class="infoboxnote" id="GUID-80AD4DA1-6AA3-42C0-8172-DECF8FB8A841__GUID-5C6D93BF-3B7B-41DA-9F7C-A1D387A9A2F6">
                        <p class="notep1">Note:</p>Use these built-in filters as starting points
                                                  only. Edit the
                                                  <code class="codeph">sun.rmi.transport.dgcFilter</code>
                                                  system property to configure reject-lists and/or
                                                  extend the allow-list to add additional protection
                                                  for Distributed Garbage Collector. To protect the
                                                  whole application, add the patterns to the
                                                  <code class="codeph">jdk.serialFilter</code> global system
                                                  property to increase protection for other
                                                  serialization users that do not have their own
                                                  custom filters.
                     </div>
                     <p>The RMI Distributed Garbage Collector has a built-in allow-list filter that accepts
                                                  a limited set of classes. It includes instances of
                                                  the <code class="codeph">java.rmi.server.ObjID</code>,
                                                  <code class="codeph">java.rmi.server.UID</code>,
                                                  <code class="codeph">java.rmi.dgc.VMID</code>, and
                                                  <code class="codeph">java.rmi.dgc.Lease</code> classes.
                     </p>
                     <div class="p">The built-in filter includes size limits:&nbsp;
                <pre class="pre codeblock"><code>maxarray=1000000;maxdepth=20</code></pre></div>
                     <p>Supersede the built-in filter by defining a filter using the <code class="codeph">sun.rmi.transport.dgcFilter</code> system property with a pattern. If the filter accepts classes passed to the filter, or rejects classes or sizes, the built-in filter is not invoked.&nbsp; If the superseding filter does not accept or reject anything, the built-filter is invoked.
                     </p>
                  </div>
                  <!-- class="section" -->
                  <div class="section">
                     <p class="subhead2" id="GUID-80AD4DA1-6AA3-42C0-8172-DECF8FB8A841__GUID-AD9BEFEA-80D5-49C8-88EC-766F2D2BE3C9">Filters for JMX</p>
                     <div class="infoboxnote" id="GUID-80AD4DA1-6AA3-42C0-8172-DECF8FB8A841__GUID-18C1AE44-4CD3-4784-A68C-E0C6293EF633">
                        <p class="notep1">Note:</p>Use these built-in filters as starting points
                                                  only. Edit the
                                                  <code class="codeph">jmx.remote.rmi.server.serial.filter.pattern</code>
                                                  management property to configure reject-lists
                                                  and/or extend the allow-list to add additional
                                                  protection for JMX. To protect the whole
                                                  application, add the patterns to the
                                                  <code class="codeph">jdk.serialFilter</code> global system
                                                  property to increase protection for other
                                                  serialization users that do not have their own
                                                  custom filters. 
                     </div>
                     <p>JMX has a built-in filter to limit a set of classes allowed to be sent as a deserializing parameters over RMI to the server. That filter is disabled by default. To enable the filter, define the <code class="codeph">jmx.remote.rmi.server.serial.filter.pattern</code> management property with a pattern. 
                     </p>
                     <p>The pattern must include the types that are allowed to be sent as parameters over RMI to the server and all types they depends on, plus <code class="codeph">javax.management.ObjectName</code> and <code class="codeph">java.rmi.MarshalledObject</code> types. For example, to limit the allowed set of classes to Open MBean types and the types they depend on, add the following line to <code>management.properties</code> file. 
                     </p><pre class="pre codeblock"><code>com.sun.management.jmxremote.serial.filter.pattern=java.lang.*;java.math.BigInteger;java.math.BigDecimal;java.util.*;javax.management.openmbean.*;javax.management.ObjectName;java.rmi.MarshalledObject;!* </code></pre></div>
                  <!-- class="section" -->
               </div>
            </div>
            <div class="sect2"><a id="GUID-6A048F49-052E-4591-9183-2775DC50831E" name="GUID-6A048F49-052E-4591-9183-2775DC50831E"></a><h3 id="JSCOR-GUID-6A048F49-052E-4591-9183-2775DC50831E" class="sect3">Logging Filter Actions</h3>
               <div>
                  <p>You can turn on logging to record the initialization, rejections, and
        acceptances of calls to serialization filters. Use the log output as a diagnostic tool to
        see what's being deserialized, and to confirm your settings when you configure allow-lists
        and reject-lists.</p>
                  <p> When logging is enabled, filter actions are logged to the <span class="apiname" translate="no">java.io.serialization</span> logger. 
                  </p>
                  <p>To enable serialization filter logging, edit the <code class="codeph">$JDK_HOME/conf/logging.properties</code> file.
                  </p>
                  <p>To log calls that are rejected, add</p><pre class="pre codeblock"><code>java.io.serialization.level = FINE</code></pre><p>To log all filter results, add</p><pre class="pre codeblock"><code>java.io.serialization.level = FINEST</code></pre></div>
            </div>
         </div>
      </article>
   </body>
</html>
