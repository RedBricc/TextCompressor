// 211RDB204 Juris Ozoliņš
// 211RDB276 Toms Zvirbulis

import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.IOException;
import java.io.OutputStreamWriter;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.Queue;
import java.util.Scanner;


public class Main {
	static Scanner sc;

	public static void main(String[] args) {
		String choiseStr;
		String fileName, outFileName, firstFile, secondFile;
		
		loop: while (true) {
			
			sc = new Scanner(System.in);
			choiseStr = sc.next();
								
			switch (choiseStr) {
			case "comp":
				System.out.print("source file name: ");
				fileName = sc.next();
				System.out.print("archive name: ");
				outFileName = sc.next();
				comp(fileName, outFileName);
				break;
			case "decomp":
				System.out.print("archive name: ");
				fileName = sc.next();
				System.out.print("file name: ");
				outFileName = sc.next();
				decomp(fileName, outFileName);
				break;
			case "size":
				System.out.print("file name: ");
				fileName = sc.next();
				size(fileName);
				break;
			case "evaluate":
				System.out.print("first file name: ");
				firstFile = sc.next();
				System.out.print("second file name: ");
				secondFile = sc.next();
				eavluate(firstFile, secondFile);
				break;
			case "equal":
				System.out.print("first file name: ");
				firstFile = sc.next();
				System.out.print("second file name: ");
				secondFile = sc.next();
				System.out.println(equal(firstFile, secondFile));
				break;
			case "about":
				about();
				break;
			case "test":
				comp("input.txt", "temp.dat");
				decomp("temp.dat", "decomp.txt");
				System.out.println(equal("input.txt", "decomp.txt") ? "Test completed" : "Test Failed!");
				eavluate("input.txt", "temp.dat");
				comp("File1.html", "temp.dat");
				decomp("temp.dat", "decomp.html");
				System.out.println(equal("File1.html", "decomp.html") ? "Test completed" : "Test Failed!");
				eavluate("File1.html", "temp.dat");
				comp("File2.html", "temp.dat");
				decomp("temp.dat", "decomp.html");
				System.out.println(equal("File2.html", "decomp.html") ? "Test completed" : "Test Failed!");
				eavluate("File2.html", "temp.dat");
				comp("File3.html", "temp.dat");
				decomp("temp.dat", "decomp.html");
				System.out.println(equal("File3.html", "decomp.html") ? "Test completed" : "Test Failed!");
				eavluate("File3.html", "temp.dat");
				comp("File4.html", "temp.dat");
				decomp("temp.dat", "decomp.html");
				System.out.println(equal("File4.html", "decomp.html") ? "Test completed" : "Test Failed!");
				eavluate("File4.html", "temp.dat");
				break;
			case "exit":
				break loop;
			}
		}

		sc.close();
	}

	public static void comp(String fileName, String outFileName) {
		// Get character data from input file.
		HashMap<Byte, Integer> words = new HashMap<Byte, Integer>();
		Boolean nullFound = false;
		FileInputStream file;
		byte[] bytes;
		try {
			// Take input file and convert it to byte array.
			file = new FileInputStream(fileName);
			bytes = new byte[file.available()];
			file.read(bytes);
			file.close();
		} catch (FileNotFoundException ex) {
			ex.printStackTrace();
			return;
		} catch (IOException e) {
			e.printStackTrace();
			return;
		}
		// Save individual characters and keep track of how many times they're used.
		for (byte b : bytes) {
			if(b == 1) {
				nullFound = true;
			}
			if(words.containsKey(b)) {
				words.merge(b, 1, Integer::sum);
			}else {
				words.put(b, 1);
			}
		}
		
		// If necessary, find a free byte in the text that will be used to replace any characters with the value of 0 (null).
		// The tree decompiling process relies on this symbol to not be present.
		byte nullByte = 1;
		if(nullFound) {
			for(int i = 2; i < 256; i++) {
				if(!words.containsKey((byte)(i))) {
					nullByte = (byte)(i);
				}
			}
		}
		
		// Create frequency tree using char values used for future size reference.
		CompTree tree = new CompTree(words.entrySet(), nullByte);
		//tree.PrintData();
		//CompTree.PrintTree(tree.top);
		
		// Save to file.
		try {
			FileOutputStream out = new FileOutputStream(outFileName);
			out.write(tree.Compile(bytes, nullByte));
			out.close();
		} 
		catch (Exception ex) {
			ex.printStackTrace();
		}
	}

	public static void decomp(String fileName, String outFileName) {
		FileInputStream in = null;
		byte[] bytes;
		try {
			// Take input file and convert it to byte array.
			in = new FileInputStream(fileName);
			bytes = new byte[in.available()];
			in.read(bytes);
			in.close();
		} catch (FileNotFoundException ex) {
			ex.printStackTrace();
			return;
		} catch (IOException e) {
			e.printStackTrace();
			return;
		}
		
		Value top;
		
		byte fillerBits = bytes[0];
		//byte compLayer = bytes[1];
		byte nullByte = bytes[2];
		
		// Reassemble frequency tree.
		Queue<Value> queue = new LinkedList<Value>();
		int cursor = 3;
		top = new Value(bytes[cursor]);
		queue.add(top);
		
		while(queue.size() != 0) {
			Value val = queue.poll();
			if(val.key == 0) {
				for(int i = 0; i < Value.childCount; i++) {
					val.child[i] = new Value(bytes[++cursor]);
					if(bytes[cursor] == 0) {
						queue.add(val.child[i]);
					}
				}
			}
		}
		
		//CompTree.PrintTree(top);
		
		// Decode text and save it as byte array.
		int bitCursor = 7;
		ArrayList<Byte> text = new ArrayList<Byte>();
		Value val = top;
		cursor++;
		while(cursor < bytes.length-1 || (cursor == bytes.length-1 && (bitCursor > fillerBits || val.key != 0))) {
			if(val.key == 0) {
				val = val.child[(bytes[cursor] >> bitCursor) & 1];
				if(bitCursor > 0) {
					bitCursor--;
				} else {
					bitCursor = 7;
					cursor++;
				}
			} else {
				if(val.key == nullByte) {
					text.add((byte) 0);
				} else {
					text.add(val.key);
				}
				val = top;
			}
			if(cursor == bytes.length-1) {
				System.out.printf("%d: %s %s added %s\n", cursor, (bitCursor), fillerBits, val.key);
			}
		}
		byte output[] = new byte[text.size()];
		int index = 0;
		
		for(Byte b : text) {
			output[index++] = b;
		}
		
		// Save to file.
		try {
			FileOutputStream out = new FileOutputStream(outFileName);
			out.write(output);
			out.close();
		} 
		catch (Exception ex) {
			ex.printStackTrace();
		}
	}
	
	public static void eavluate(String firstFile, String secondFile) {
		Double first, second;
		try {
			FileInputStream f = new FileInputStream(firstFile);
			first = (double) f.available();
			f.close();
			f = new FileInputStream(secondFile);
			second = (double) f.available();
			f.close();
		}
		catch (IOException ex) {
			System.out.println(ex.getMessage());
			return;
		}
		System.out.printf("%s to %s saves %.1f%%\n", firstFile, secondFile, ((1-second/first)*100));
	}
	
	public static void size(String fileName) {
		try {
			FileInputStream f = new FileInputStream(fileName);
			System.out.println("size: " + f.available());
			f.close();
		}
		catch (IOException ex) {
			System.out.println(ex.getMessage());
		}
		
	}
	
	public static boolean equal(String firstFile, String secondFile) {
		try {
			FileInputStream f1 = new FileInputStream(firstFile);
			FileInputStream f2 = new FileInputStream(secondFile);
			int k1, k2;
			byte[] buf1 = new byte[f1.available()];
			byte[] buf2 = new byte[f2.available()];
			do {
				k1 = f1.read(buf1);
				k2 = f2.read(buf2);
				if (k1 != k2) {
					f1.close();
					f2.close();
					return false;
				}
				for (int i=0; i<k1; i++) {
					if (buf1[i] != buf2[i]) {
						f1.close();
						f2.close();
						return false;
					}
						
				}
			} while (k1 == 0 && k2 == 0);
			f1.close();
			f2.close();
			return true;
		}
		catch (IOException ex) {
			System.out.println(ex.getMessage());
			return false;
		}
	}
	
	public static void about() {
		// TODO insert information about authors
		System.out.println("211RDB204 Juris Ozoliņš");
		System.out.println("211RDB276 Toms Zvirbulis");
	}
}
