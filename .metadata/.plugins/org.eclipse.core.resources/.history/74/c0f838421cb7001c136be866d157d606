import java.util.PriorityQueue;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Map.Entry;
import java.util.Set;


// Functions needed to encode text files to byte array.
public class CompTree {
	public CompTree(Set<Entry<Byte, Integer>> set, byte nullByte) {
		// Convert character data into sorted array.
		for(Entry<Byte, Integer> e : set) {
			Value val = new Value(e.getKey(), e.getValue());
			if(val.key == 0) {
				val.key = nullByte;
			}
			int index = 0;
			while(index < data.size() && data.get(index).value < val.value) {
				index++;
			}
			data.add(index, val);
			map.put(val.key, data.get(index));
		}
		
		PriorityQueue<Value> dataQueue = new PriorityQueue<Value>(data);
		
		// Convert sorted array into tree of values. The largest values are at the top.
		while(dataQueue.size() > 1) {
			Value c[] = new Value[Value.childCount];
			for(int i = 0; i < c.length; i++) {
				c[i] = dataQueue.poll();
			}
			Value parent = new Value(c, Value.childSum(c));
			
			// Save parent information for traversal as well as side for path building later.
			for(byte i = 0; i < c.length; i++) {
				c[i].parent = parent;
				c[i].side = i;
			}
			
			dataQueue.add(parent);
			treeSize+=Value.childCount;
		}
		
		top = dataQueue.poll();
	}
	
	// Returns byte array of encoded data with header.
	public byte[] Compile(byte bytes[], byte nullByte) {
		byte[] head = TreeToBytes();
		
		ArrayList<Byte> body = new ArrayList<Byte>();
		Byte curByte = 0;
		int index = 0;
		for(byte by : bytes) {
			for(byte bit : GetPath((by == 0) ? nullByte : by)) {
				curByte = (byte) (curByte | (bit << (7-(index++))));
				if(index >= 8) {
					body.add(curByte);
					curByte = 0;
					index = 0;
				}
			}
		}
		if(index != 8) {
			body.add(curByte);
		}
		byte[] out = new byte[3+head.length+body.size()];
		// Store information about how many filler bits exist at the end of the file as well as what compression iteration level was used
		// and what character codes for null.
		out[0] = (byte)(7-index);
		out[1] = (byte)(0);
		out[2] = nullByte;
		
		// Assemble final output.
		index = 3;
		for(byte h : head) {
			out[index++] = h;
		}
		for(byte b : body) {
			out[index++] = b;
		}
		
		return out;
	}
}
